## Concurrency(並行)
- 同時にいくつかの質のことなることを扱う
- 本を積む、本を運ぶ、本を燃やす

## Parallelism(並列)
- 同時にいくつかの質の同じことを扱う
- 本を燃やす、本を燃やす、本を燃やす

## ゴールーチンでConcurrencyを実現
- 複数のゴールーチンで同時に複数のタスクをこなす
- 各ゴールーチンに役割を与えて分業する
- 軽量なスレッドのようなもの
- 1つのスレッドの上で複数のゴールーチンが動く

## ゴールーチンの作り方

```
go func() {
  処理の内容
}
```

## ゴールーチン間のデータのやりとり
- どのゴールーチンが先にアクセスするかわからない
→ 値の変更や参照が競合する
- チャネルを使ってゴールーチン間で通信する

## チャネル
- ゴールーチン1, 2をつなぐパイプのようなもの。
- ch <- 100 (チャネルに100を入れる)
-  <- ch (チャネルから値を取り出す)

## チャネルの特長
- チャネルを定義する際に型を指定する
- バッファをもたせることができる。指定しないと容量0
- チャネルの容量がいっぱいだと、受け取るまでブロックする。

### 初期化
ch1 := make(chan int)
ch2 := make(chan int, 10)

### 送信
ch1 <- 10 ←受け取られるまでブロック(容量0だから)
ch2 <- 10 + 20 ←いっぱいであればブロック(容量10だから)

### 受信
n1 := <-ch1 ←送信されるまでブロック
n2 := <-ch2 + 100 ←空であればブロック
※受信が行われた = どこかから送信がされた

```
func main() {
	ch := make(chan int) // 容量0

	// goroutine-1
	go func() {
		ch <- 100
	}()

	// goroutine-2 こっちが先に実行されると、送信がないため、goroutine-1にて送信されるまでブロック
	go func() {
		v := <-ch
		fmt.Println(v)
	}()

	time.Sleep(2 * time.Second)
}

```
→ 必ず処理の同期がとれる。

### select-case

- ch1とch2で早いほうがどんどん処理される(他のchを待たない)

```
func main() {
	ch1 := make(chan int)
	ch2 := make(chan string)
	go func() { ch1 <- 100 }()
	go func() { ch2 <- "hi" }()

select {
	case v1 := <-ch1:
		fmt.Println(v1)
	case v2 := <-ch2:
		fmt.Println(v2)
	}
}

```

### チャネルはファーストクラスオブジェクト
- 変数へ代入可能
- 引数にわたす
- 戻り値で返す
- チャネルのチャネル(cf. timeパッケージ)

### syncパッケージ
- チャネルだけを使っているとコードが難解になる。
- 入力と出力が違う型の場合もある。

### ロック
- sync.Mutex
- Lockメソッドを呼ぶとUnlockメソッドが呼ばれるまでブロックする

### 書き込みロック・読み込みロック
- sync.RWMutex

### 複数のゴールーチンの待機
- sync.WaitGroup
- Addメソッドに渡した合計の回数だけDoneメソッドを呼ぶ
- Waitメソッドで処理をブロックして待機する

### コンテキスト
- Contextインターフェース
- ゴールーチンをまたいだキャンセル処理
